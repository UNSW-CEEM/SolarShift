This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-04-02T23:29:51.685Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.python-version
data_preprocessing.py
pyproject.toml
README.md
solar_shift.py

================================================================
Files
================================================================

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
.idea/

# PyPI configuration file
.pypirc

# Project
solar-shift.code-workspace

uv.lock
*.csv
graphics.py

================
File: .python-version
================
3.12

================
File: data_preprocessing.py
================
import pandas as pd

group_columns = {
    "location": "Location",
    "household_size": "Household occupants",
    "tariff_type": "Hot water bill type",
    "heater_type": "Heater",
    "control_type": "Heater control",
    "has_solar": "Solar",
    "profile_HWD": "Hot water usage pattern",
}

groups = list(group_columns.values())

metric_columns = {
    "net_present_cost": "Net present cost ($)",
    "capital_cost": "Up front cost ($)",
    "rebates": "Rebates ($)",
    "annual_energy_cost": "Annual cost ($/yr)",
    "annual_fit_opp_cost": "Decrease in solar export revenue ($/yr)",
    "emissions_total": "CO2 emissions (tons/yr)",
    "annual_energy_consumption": "Annual energy consumption (kWh)"
}

metrics = list(metric_columns.values())


def load_and_preprocess_data():
    """Reads hotwater simulation results from CSVs and renames columns and values to
    more user-friendly conventions.
    """
    data = pd.read_csv("hotwater_data.csv")
    data = data.rename(columns=group_columns)
    data = data.rename(columns=metric_columns)

    data["Heater"] = data["Heater"].map(
        {
            "resistive": "Electric",
            "heat_pump": "Heat Pump",
            "solar_thermal": "Solar Thermal",
            "gas_instant": "Gas Instant",
            "gas_storage": "Gas Storage",
        }
    )

    data["Heater control"] = data["Heater control"].map(
        {
            "GS": "Run as needed (no control)",
            "CL1": "On overnight",
            "CL2": "Off during peak billing times",
            "CL3": "On overnight and sunny hours",
            "timer_SS": "On sunny hours",
            "diverter": "Active matching to solar",
            "timer_OP": "On during off-peak billing times"
        }
    )

    data["Hot water usage pattern"] = data["Hot water usage pattern"].map(
        {
            1: "Morning and evening only",
            2: "Morning and evening with day time",
            3: "Evenly distributed",
            4: "Morning",
            5: "Evening",
            6: "Late Night",
        }
    )

    data["Hot water bill type"] = data["Hot water bill type"].map(
        {
            "flat": "Flat rate electricity",
            "tou": "Time varying rate electricity",
            "CL": "Controlled load discount electricity",
            "gas": "Flat rate gas",
        }
    )

    data["Solar"] = data["Solar"].map(
        {
            True: "Yes",
            False: "No",
        }
    )

    return data


def process_system_data(
        data,
        location,
        occupants,
        usage_pattern,
        tariff,
        heater,
        control,
        solar
):
    location_mask = data["Location"] == location
    occupants_mask = data["Household occupants"] == occupants
    usage_pattern_mask = data["Hot water usage pattern"] == usage_pattern
    tariff_mask = data["Hot water bill type"] == tariff
    heater_mask = data["Heater"] == heater
    control_mask = data["Heater control"] == control
    solar_mask = data["Solar"] == solar

    mask = (
            location_mask &
            occupants_mask &
            usage_pattern_mask &
            tariff_mask &
            heater_mask &
            control_mask &
            solar_mask
    )

    data = data.loc[mask, :]

    return data

================
File: pyproject.toml
================
[project]
name = "solar-shift"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "cairosvg>=2.7.1",
    "matplotlib>=3.10.1",
    "pandas>=2.2.3",
    "plotly>=6.0.0",
    "streamlit-extras>=0.6.0",
    "streamlit>=1.43.0",
]

================
File: README.md
================
# Solar-shift streamlit app

This repository contains the source code for the solar-shift streamlit web app.

The app is designed to make the results of the SolarShift accessible to consumer to 
help inform their hot water heater purchasing decisions. More information on the project
can be found here: https://www.ceem.unsw.edu.au/our-research/solarshift.

# App technology

The app is built predominately using the streamlit Python package. The package is 
relatively straight forward to use once the core concepts are understood. The streamlit
intro docs are a great place to start understanding streamlit: 
https://docs.streamlit.io/get-started

# Running the app on a local machine

To run the app on your machine use the following steps:

1. install the `uv` python package manager

   Windows:

    `powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"`

   MacOS and Linux:

   `curl -LsSf https://astral.sh/uv/install.sh | sh`

2. use `uv` to install python 3.12 if you don't already have it:

   `uv python install 3.12`

3. use `uv` to install the solar-shift web app dependencies:

   `uv sync`

4. use `uv` to run the webapp locally:

   `uv run streamlit run solar_shift.py`

# App architecture 

   - `streamlit.py`: Most of the code for the webapp is located in the file 
     streamlit.py. With the five tabs of the web defined sequential in the file.
   - `data_preprocessing.py`: Before the data is used directly in the webapp it is 
     loaded from the csv into pd.DataFrame and reformatted in the function 
     load_and_preprocess_data defined in the file data_preprocessing.py
   - `graphics.py`: The code for drawing the image on the home page, the website icon
      and apply chart formatting are in the file graphics.py
   - `pyproject.toml`: The project dependencies are defined in pyproject.toml.

# Upkeep and maintenance 

## Updating the results data

- The data the webapp displays can be updated by changing the `hotwater_data.csv` file. 
  If the naming conventions are kept the same the webapp code should not need to be 
  modified.

- If new parameter columns are added to the data then the web app may need to be 
  updated in serval places, including in data_preprocessing.py, and anywhere widgets 
  for filter or aggregating data are defined.

- If data naming conventions are changed then data_preprocessing.py and anywhere a data
  column is referenced in streamlit.py may need to be updated.

## Webapp hosting

To be completed once hosting is finalised.

================
File: solar_shift.py
================
import streamlit as st
from streamlit_extras.stylable_container import stylable_container
from streamlit.components.v1 import html
import pandas as pd
import plotly.express as px
import time
from PIL import Image

from graphics import (
    draw_logo,
    apply_chart_formatting
)

from data_preprocessing import (
    load_and_preprocess_data,
    metrics,
    groups,
    process_system_data
)

# Get image used as icon in web browser tab.
im = Image.open("favicon.png")


st.set_page_config(
    page_title="Explore!",
    layout="wide",
    page_icon=im
)

# Set width of page content to 90% of web browser width.
st.html("""
    <style>
        .stMainBlockContainer {
            max-width: 90vw;
        }
    </style>
    """
)

# Decrease the white space padding around the main content.
st.markdown("""
<style>

.block-container
{
    max-width: 1300px;
    padding-top: 1rem;
    padding-bottom: 0rem;
    margin-top: 1rem;
}

</style>
""", unsafe_allow_html=True)


# Wrap the data loading function in a function with streamlit caching enabled. This way
# the function is only run once when the app is launched.
@st.cache_data
def get_data():
    return load_and_preprocess_data()


data = get_data()

# Create the tabs of the webpage.
home, about, explore, compare, detailed_info = \
    st.tabs(["Home", "About", "Explore", "Compare", "Details"])


# Create a function that allows the two buttons at the bottom of the homepage to take
# the user to another tab.
def switch(tab):
    return f"""
var tabGroup = window.parent.document.getElementsByClassName("stTabs")[0]
var tab = tabGroup.getElementsByTagName("button")
tab[{tab}].click()
"""


# Create Home page tab contents.
with home:
    # Main heading.
    st.markdown(
        "<h1 style='text-align: center; color: #FFA000;'>Welcome to the Solar Shift Explorer!</h1>",
        unsafe_allow_html=True
    )

    # Home page picture.
    st.markdown(draw_logo(), unsafe_allow_html=True)

    # Columns to space buttons out.
    a, b, c, d = st.columns([0.3, 1, 1, 0.4])

    # Button to take user to the Explore tab.
    with b:
        with stylable_container(
                key="Upload_Data",
                css_styles="""
                    button{
                        float: right;
                    }
                    """
        ):
            if st.button("Explore a variety of hot water solutions"):
                with st.empty():
                    html(f"<script>{switch(2)}</script>", height=0)
                    time.sleep(1)
                    html(f"<div></div>", height=0)

    # Button to take user to the Compare tab.
    with c:
        if st.button("Compare two hot water solutions side-by-side"):
            with st.empty():
                html(f"<script>{switch(3)}</script>", height=0)
                time.sleep(1)
                html(f"<div></div>", height=0)

# Create About contents tab.
with about:
    st.markdown("Here we will describe the project.")

# Create Explore tab contents.
with explore:

    # Write heading at the top of tab.
    with st.container():
        st.markdown(
            "<h3 style='text-align: center; color: #FFA000;'>Explore hot water system configurations</h1>",
            unsafe_allow_html=True)

    # Create container  which holds data selectors and plot.
    with st.container():

        # Create left column for data selectors and right column for plot.
        left, gap, right = st.columns([1.75, 0.25, 5])

        # Create the data selectors that control what gets plotted and the contents of
        # the table at the bottom of the page.
        with left:
            # Create some space to push the selectors down the page a litte.
            st.markdown("<br>", unsafe_allow_html=True)

            # Create the data selectors.
            with st.expander("Describe your house", expanded=False):
                hs = st.multiselect(
                    "Household size",
                    data["Household occupants"].unique(),
                    default=3,
                    help="The number of people living in the house."
                )
                locs = st.multiselect("Location", data["Location"].unique())
                patterns = st.multiselect(
                    "Hot water usage pattern",
                    data["Hot water usage pattern"].unique(),
                    help="When hot water typically used in the house."
                )
                tariffs = st.multiselect(
                    "Hot water bill type",
                    data["Hot water bill type"].unique(),
                    help="""
                    How energy used for heating hot water is paid for. 
                    
                    This needs to match with the Heater type options
                    selected and the Control type options. E.g. to view 
                    gas heater options, gas also needs to be a bill type
                    option. Similarly, to use Control Type options that
                    restrict when the heater is run the 
                    'Control load discount electricity' needs to be an
                    option.
                    """
                )
                solar = st.multiselect(
                    "Solar",
                    data["Solar"].unique(),
                    help="If the house has a Solar electricity system."
                )
            with st.expander("Choose a heater"):
                heater = st.multiselect("Heater type", data["Heater"].unique())
                control = st.multiselect("Control type", data["Heater control"].unique())
            with st.expander("Compare"):
                # These control how the selected data is plotted.
                # Create a selector which controls how the data is grouped on the x-axis
                # with a default setting of Heater.
                index = groups.index("Heater")
                x = st.selectbox("Side-by-side", groups, index=index)
                # Create a selector which controls how the data is colored with a
                # default setting of Heater.
                color = st.selectbox("Color", groups, index=index)
                index = metrics.index("Annual cost ($/yr)")
                metric = st.selectbox("Comparison metric", metrics, index=index)

            # Filter the data using the values from the data selectors defined above.
            f_data = data.copy()
            if len(hs) > 0:
                f_data = f_data[f_data["Household occupants"].isin(hs)]
            if len(locs) > 0:
                f_data = f_data[f_data["Location"].isin(locs)]
            if len(patterns) > 0:
                f_data = f_data[f_data["Hot water usage pattern"].isin(patterns)]
            if len(tariffs) > 0:
                f_data = f_data[f_data["Hot water bill type"].isin(tariffs)]
            if len(solar) > 0:
                f_data = f_data[f_data["Solar"].isin(solar)]
            if len(control) > 0:
                f_data = f_data[f_data["Heater control"].isin(control)]
            if len(heater) > 0:
                f_data = f_data[f_data["Heater"].isin(heater)]

            # Create copy of the data for displaying in a table at the bottom of the
            # Explore tab.
            show_data = f_data.loc[:, groups + metrics]

        # Create the data plot.
        with right:

            chart = px.strip(
                f_data,
                y=metric,
                x=x,
                color=color
            )

            chart.update_traces(width=2.0)

            apply_chart_formatting(chart)

            st.plotly_chart(chart, use_container_width=True)

    # Create a container for displaying the chart data in a table.
    with st.container():
        # A radio selector that allows the user to choose between averaging the data
        # before displaying in the table or display the data for all selected data.
        summarise = st.radio("Data display option", ["Average", "Show all"], label_visibility="collapsed")
        # If user selects Average the data is average across groups which are the
        # combination of the chosen x-axis group and plotting color.
        table_groups = list(set((x, color)))
        if len(table_groups) > 0 and summarise == "Average":
            agg_dict = {col: "mean" for col in metrics}
            show_data = show_data.groupby(table_groups, as_index=False).agg(agg_dict)
        show_data = show_data.sort_values("Net present cost ($)")
        st.dataframe(show_data.style.format(precision=2), hide_index=True)

# Create contents of the Compare tab.
with (compare):

    # Create a helper function which is used to create selectors.
    def create_select(group, default, version):
        options = list(data[group].unique())
        index = options.index(default)
        key = f"select-{group}-{version}"
        return st.selectbox(group, options, index=index, key=key)

    # Create the heading at the top of the tab.
    st.markdown(
        "<h3 style='text-align: center; color: #FFA000;'>Compare two hot water systems in detail</h1>",
        unsafe_allow_html=True
    )

    # Create columns for the tab layout, left column for selectors and right column
    # for charts.
    left, gap, right = st.columns([1.75, 0.25, 5])

    with left:
        # Create the selectors for defining "System One" in the comparison.
        with st.expander("System one details", expanded=True):
            location_one = create_select("Location", "Sydney", "one")
            occupants_one = create_select("Household occupants", 3, "one")
            usage_pattern_one = create_select("Hot water usage pattern",
                                              "Morning and evening only", "one")
            solar_one = create_select("Solar", "Yes", "one")
            heater_one = create_select("Heater", "Heat Pump", "one")
            tariff_one = create_select("Hot water bill type", "Flat rate electricity", "one")
            control_one = create_select("Heater control", "Run as needed (no control)",
                                        "one")

        # Create the selectors for defining "System One" in the comparison.
        with st.expander("System two details"):
            location_two = create_select("Location", "Sydney", "two")
            occupants_two = create_select("Household occupants", 3, "two")
            usage_pattern_two = create_select("Hot water usage pattern",
                                              "Morning and evening only", "two")
            solar_two = create_select("Solar", "Yes", "two")
            heater_two = create_select("Heater", "Electric", "two")
            tariff_two = create_select("Hot water bill type", "Flat rate electricity", "two")
            control_two = create_select("Heater control",
                                        "Run as needed (no control)",
                                        "two")

    with right:

        # Filter and aggregate data for System One.
        system_one_data = process_system_data(
            data,
            location_one,
            occupants_one,
            usage_pattern_one,
            tariff_one,
            heater_one,
            control_one,
            solar_one
        )

        # Add a column labeling the data as System One
        system_one_data.insert(0, "System", "One")

        # Filter and aggregate data for System One.
        system_two_data = process_system_data(
            data,
            location_two,
            occupants_two,
            usage_pattern_two,
            tariff_two,
            heater_two,
            control_two,
            solar_two
        )

        # Add a column labeling the data as System Two
        system_two_data.insert(0, "System", "Two")

        # Combine system one and two data for plotting and displaying in tables.
        system_comparison_data = pd.concat([system_one_data, system_two_data])

        # Create net present cost plot.
        with st.expander("Simple financial comparison", expanded=False):

            columns_to_plot = ["Net present cost ($)"]

            bar_chart = px.bar(
                system_comparison_data, x="System", y=columns_to_plot, barmode="group"
            )

            apply_chart_formatting(
                bar_chart, yaxes_title="Net present cost ($)", show_legend=False, height=200
            )

            st.plotly_chart(
                bar_chart,
                use_container_width=True,
                key="Net present cost ($)",
            )

        # Create cashflow plot.
        with st.expander("Spending", expanded=True):

            columns_to_plot = [
                "Up front cost ($)",
                "Rebates ($)",
                "Annual cost ($/yr)",
                "Decrease in solar export revenue ($/yr)"
            ]

            bar_chart = px.bar(
                system_comparison_data, x="System", y=columns_to_plot, barmode="group", height=200
            )

            apply_chart_formatting(bar_chart, yaxes_title="Costs")

            st.plotly_chart(
                bar_chart,
                use_container_width=True,
                key="Spending"
            )

        # Create CO2 plot.
        with st.expander("Environmental comparison", expanded=False):

            columns_to_plot = ["CO2 emissions (tons/yr)"]

            bar_chart = px.bar(
                system_comparison_data, x="System", y=columns_to_plot, barmode="group", height=200
            )

            apply_chart_formatting(
                bar_chart, yaxes_title="CO2 emissions (tons/yr)", show_legend=False
            )

            st.plotly_chart(
                bar_chart,
                use_container_width=True,
                key="Environmental",
            )

        # Create table with comparison of system configurations.
        with st.expander("Tabular details comparison", expanded=False):

            comp = pd.DataFrame({
                "Option": ["Location", "Household occupants", "Hot water usage pattern", "Solar", "Heater", "Hot water bill type", "Heater control"],
                "System one": [location_one, str(occupants_one), usage_pattern_one, solar_one, heater_one, tariff_one, control_one],
                "System two": [location_two, str(occupants_two), usage_pattern_two, solar_two, heater_two, tariff_two, control_two],
            })

            st.dataframe(comp, hide_index=True)

        # Create table with system performance metrics.
        with st.expander("Tabular performance comparison", expanded=False):

            # This hides these columns.
            column_config = {
                "Location": None,
                "Household occupants": None,
                "Hot water bill type": None,
                "Heater": None,
                "Heater control": None,
                "Solar": None,
                "Hot water usage pattern": None

            }

            # Create copy of the data for displaying in a table at the bottom of the
            # Explore tab.
            system_comparison_data = system_comparison_data.loc[:, ["System"] + groups + metrics]

            st.dataframe(system_comparison_data, hide_index=True, column_config=column_config)

        with st.container():
            st.info(
                '''
                Note: Some Heater/Heater control/Tariff combinations are not available. 
                If no inputs are returned try adjusting the selected control or tariff option.
                Read further about the available options in the **Details** tab.
                '''
            )

# Create content for Detail tab.
with detailed_info:
    st.markdown("""
    
    ## Contents
    
    1. [Hot water heaters](#hot-water-heaters)
    1. [Hot water control](#hot-water-control)
    1. [Options explored](#options-explored)
    
    ## 1. Hot water heaters
    
    ### 1.1 Electric
    
    Electric hot water heaters refer to electric tank based systems. Electric hot water
    systems use a resistive element similar to those found in an oven to heat a tank of
    hot water. The tank allows the hot water to be heated and then stored, which means
    these systems can be operated very flexibly, heating when electricity is cheaper, such as overnight, or when solar electricity is available, with the hot water stored 
    for use later. These systems are very simple and, therefore, are cheap to 
    install. Electric hot water heaters can also be paired with a solar electricity 
    diverter, which measures how much electricity is being exported to the grid and 
    adjusts the heater power consumption to match the amount of spare solar electricity. 
    Diverters add to the cost and complexity of the system but can lower electricity bills 
    and carbon emissions.  
    
    ### 1.2 Heat pump
    
    Heat pumps use the same technology found in fridges and air conditioners to suck heat 
    out of the air and pump it into water. As the heat comes from the air rather than
    directly from electricity, they typically use much less energy than simple electric 
    hot water heaters. However, similar to an electric hot water heater, they use a tank 
    to store the hot water, so it can be run flexibly when electricity is 
    cheaper, such as overnight or during the day when solar electricity is available. 
    Heat pumps tend to be more expensive to buy but cheaper to run than simple electric 
    hot water systems.
    
    ### 1.3 Gas instant
    
    Instantaneous gas hot water systems turn on only when you turn on your hot water tap, 
    heating the water on demand as it is needed. They tend to be cheap to install and have a
    moderate running cost. However, there isn't any scope to reduce emissions or lower
    running costs by combining this type of hot water system with solar electricity.
    
    ### 1.4 Gas storage
    
    Gas storage systems use gas to heat the hot water, which is then stored in a tank. 
    These systems tend to be a bit more expensive to install and run compared to 
    instantaneous gas.
    
    ### 1.5 Solar thermal
    
    Solar thermal systems use the sun to heat the water directly, which is then stored in
    a tank for later use. In the Solar Shift project, we also assumed that the Solar 
    thermal systems had an electric booster that heated the hot water tank when its
    temperature dropped below a preset temperature. Solar thermal systems tend to be 
    expensive to install and relatively cheap to run. Additionally, because the sun is 
    being used to heat the water directly, they use less roof space than is required by solar 
    electricity systems. However, the complexity of running water pipes on and off your 
    roof, as well as the pumps needed for some systems is an additional 
    consideration.
    
    ## 2. Hot water control
    
    Some hot water systems can be controlled so they use electricity when it is cheaper 
    or when solar electricity is available. The various control strategies 
    explored in the Solar Shift simulations are described below.
    
    ### 2.1 Run as needed (no control)
    
    Run as needed means the hot water system will just run as per its internal 
    control system. For Electric, Heat pump, and Gas storage, this means the heater will
    run when the water in the tank falls below a preset temperature. For Gas Instant, 
    the heater will run when hot water is used. For Solar thermal the heater
    will run when the sun is shining or the temperature drops below a preset 
    value.
    
    ### 2.2. Off during peak usage times
    
    This control option means the water heater is restricted from running during local 
    peak electricity usage times. The control option is only available for Electric and 
    Heat pump hot water heaters and with the 'Controlled load discount electricity' bill
    type.
    
    ### 2.3 On during off-peak billing times
    
    This control option means the water heater can only run during off-peak billing 
    times (as defined in time varying electricity bill). The control option is only 
    available for Electric and Heat pump hot water heaters and with the 
    'Time varying rate electricity' bill type.
    
    ### 2.4 On overnight
    
    This control option means the water heater can only run overnight. The control 
    option is only available for Electric and Heat pump hot water heaters and with the 
    'Controlled load discount electricity' bill type.
    
    ### 2.5 On overnight and sunny hours
    
    This control option means the water heater can only run overnight and during periods
    of the day that are typically sunny. The control option is only available for 
    Electric and Heat pump hot water heaters and with the 'Controlled load discount 
    electricity' bill type.
    
    ### 2.6 On sunny hours
    
    This control option means the water heater can only run during periods
    of the day that are typically sunny. The control option is only available for 
    Electric and Heat pump hot water heaters and with the 'Flat rate electricity' bill 
    type.
    
    ### 2.7 Active matching to solar
    
    This control option means the water heater runs when there is spare solar 
    electricity being exported to the grid. The control option is only available for 
    Electric heaters with the 'Flat rate electricity' or 'Controlled load discount 
    electricity' bill type.
    
    ## 3. Options explored
    
    Not all system configurations have been modelled. Typically, when system 
    configurations have not been modelled this is because the configuration does not 
    make sense from a technical perspective, e.g. it does not make sense to model a Gas
    storage heater with a Flat rate electricity bill type. The complete set of 
    configurations that have been modelled are shown in the table below.
    """
    )
    cols = ["Heater", "Heater control", "Hot water bill type", "Solar"]
    show_data = data.loc[:, cols]
    show_data = show_data.drop_duplicates(cols)
    show_data = show_data.sort_values(by=cols)
    st.dataframe(show_data, hide_index=True)



================================================================
End of Codebase
================================================================
